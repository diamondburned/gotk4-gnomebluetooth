// Code generated by girgen. DO NOT EDIT.

package gnomebluetooth

import (
	"runtime"
	"unsafe"
)

// #include <stdlib.h>
import "C"

const UUID_A2DP = 4365
const UUID_A2DP_SINK = 4363
const UUID_A2DP_SOURCE = 4362
const UUID_AVRCP_CONTROL = 4366
const UUID_AVRCP_TARGET = 4364
const UUID_DUN = 4355
const UUID_FTP = 4358
const UUID_GENERIC_AUDIO = 4611
const UUID_GENERIC_NET = 4609
const UUID_HFP_AG = 4383
const UUID_HFP_HF = 4382
const UUID_HID = 4388
const UUID_HSP = 4360
const UUID_HSP_AG = 4370
const UUID_IRMC = 4356
const UUID_OPP = 4357
const UUID_PAN_GN = 4375
const UUID_PAN_NAP = 4374
const UUID_PAN_PANU = 4373
const UUID_PBAP = 4399
const UUID_PNP = 4608
const UUID_SAP = 4397
const UUID_SDP = 4096
const UUID_SPP = 4353
const UUID_VDP_SOURCE = 4867

// AppearanceToType returns the type of device corresponding to the given
// appearance value, as usually found in the GAP service.
//
// The function takes the following parameters:
//
//    - appearance: bluetooth device appearance.
//
// The function returns the following values:
//
//    - typ: Type.
//
func AppearanceToType(appearance uint16) Type {
	var _arg1 C.guint16       // out
	var _cret C.BluetoothType // in

	_arg1 = C.guint16(appearance)

	_cret = C.bluetooth_appearance_to_type(_arg1)
	runtime.KeepAlive(appearance)

	var _typ Type // out

	_typ = Type(_cret)

	return _typ
}

// ClassToType returns the type of device corresponding to the given class
// value.
//
// The function takes the following parameters:
//
//    - class: bluetooth device class.
//
// The function returns the following values:
//
//    - typ: Type.
//
func ClassToType(class uint32) Type {
	var _arg1 C.guint32       // out
	var _cret C.BluetoothType // in

	_arg1 = C.guint32(class)

	_cret = C.bluetooth_class_to_type(_arg1)
	runtime.KeepAlive(class)

	var _typ Type // out

	_typ = Type(_cret)

	return _typ
}

// SendToAddress: start a GUI application for transfering files over Bluetooth.
//
// The function takes the following parameters:
//
//    - address: remote device to use.
//    - alias: remote device's name.
//
func SendToAddress(address, alias string) {
	var _arg1 *C.char // out
	var _arg2 *C.char // out

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(address)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(alias)))
	defer C.free(unsafe.Pointer(_arg2))

	C.bluetooth_send_to_address(_arg1, _arg2)
	runtime.KeepAlive(address)
	runtime.KeepAlive(alias)
}

// TypeToFilterString returns a human-readable string representation of type
// usable for display to users, when type filters are displayed. Do not free the
// return value. The returned string is already translated with gettext().
//
// The function takes the following parameters:
//
//    - typ: Type.
//
// The function returns the following values:
//
//    - utf8: string.
//
func TypeToFilterString(typ uint) string {
	var _arg1 C.guint  // out
	var _cret *C.gchar // in

	_arg1 = C.guint(typ)

	_cret = C.bluetooth_type_to_filter_string(_arg1)
	runtime.KeepAlive(typ)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// TypeToString returns a human-readable string representation of type usable
// for display to users. Do not free the return value. The returned string is
// already translated with gettext().
//
// The function takes the following parameters:
//
//    - typ: Type.
//
// The function returns the following values:
//
//    - utf8: string.
//
func TypeToString(typ uint) string {
	var _arg1 C.guint  // out
	var _cret *C.gchar // in

	_arg1 = C.guint(typ)

	_cret = C.bluetooth_type_to_string(_arg1)
	runtime.KeepAlive(typ)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// UUIDToString returns a string representing a human-readable (but not usable
// for display to users) version of the uuid. Do not free the return value.
//
// The function takes the following parameters:
//
//    - uuid: string representing a Bluetooth UUID.
//
// The function returns the following values:
//
//    - utf8: string.
//
func UUIDToString(uuid string) string {
	var _arg1 *C.char // out
	var _cret *C.char // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(uuid)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.bluetooth_uuid_to_string(_arg1)
	runtime.KeepAlive(uuid)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// VerifyAddress returns whether the string is a valid Bluetooth address. This
// does not contact the device in any way.
//
// The function takes the following parameters:
//
//    - bdaddr: string representing a Bluetooth address.
//
// The function returns the following values:
//
//    - ok: TRUE if the address is valid, FALSE if not.
//
func VerifyAddress(bdaddr string) bool {
	var _arg1 *C.char    // out
	var _cret C.gboolean // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(bdaddr)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.bluetooth_verify_address(_arg1)
	runtime.KeepAlive(bdaddr)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}
