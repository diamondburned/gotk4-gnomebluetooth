// Code generated by girgen. DO NOT EDIT.

package gnomebluetooth

import (
	"fmt"
	"strings"
)

// #include <stdlib.h>
import "C"

// TYPE_AUDIO: use this value to select any Bluetooth audio device where a Type
// enum is required.
const TYPE_AUDIO = 1048800

// TYPE_INPUT: use this value to select any Bluetooth input device where a Type
// enum is required.
const TYPE_INPUT = 13056

// Category: category of a Bluetooth devices.
type Category C.gint

const (
	// CategoryAll: all devices.
	CategoryAll Category = iota
	// CategoryPaired: paired devices.
	CategoryPaired
	// CategoryTrusted: trusted devices.
	CategoryTrusted
	// CategoryNotPairedOrTrusted: neither paired, nor trusted devices.
	CategoryNotPairedOrTrusted
	// CategoryPairedOrTrusted: paired and/or trusted devices.
	CategoryPairedOrTrusted
)

// String returns the name in string for Category.
func (c Category) String() string {
	switch c {
	case CategoryAll:
		return "All"
	case CategoryPaired:
		return "Paired"
	case CategoryTrusted:
		return "Trusted"
	case CategoryNotPairedOrTrusted:
		return "NotPairedOrTrusted"
	case CategoryPairedOrTrusted:
		return "PairedOrTrusted"
	default:
		return fmt.Sprintf("Category(%d)", c)
	}
}

// Column: column identifier to pass to
// bluetooth_chooser_get_selected_device_info().
type Column C.gint

const (
	// ColumnProxy: BusProxy object.
	ColumnProxy Column = iota
	// ColumnProperties: used to be BusProxy object for DBus.Properties, now
	// always NULL.
	ColumnProperties
	// ColumnAddress: string representing a Bluetooth address.
	ColumnAddress
	// ColumnAlias: string to use for display (the name of the device, or its
	// address if the name is not known). Only available for devices.
	ColumnAlias
	// ColumnName: string representing the device or adapter's name.
	ColumnName
	// ColumnType of the device. Only available for devices.
	ColumnType
	// ColumnIcon: string representing the icon name for the device. Only
	// available for devices.
	ColumnIcon
	// ColumnDefault: whether the adapter is the default one. Only available for
	// adapters.
	ColumnDefault
	// ColumnPaired: whether the device is paired to its parent adapter. Only
	// available for devices.
	ColumnPaired
	// ColumnTrusted: whether the device is trusted. Only available for devices.
	ColumnTrusted
	// ColumnConnected: whether the device is connected. Only available for
	// devices.
	ColumnConnected
	// ColumnDiscoverable: whether the adapter is discoverable/visible. Only
	// available for adapters.
	ColumnDiscoverable
	// ColumnDiscovering: whether the adapter is discovering. Only available for
	// adapters.
	ColumnDiscovering
	// ColumnLegacypairing: whether the device does not support Bluetooth 2.1
	// Simple Secure Pairing. Only available for devices.
	ColumnLegacypairing
	// ColumnPowered: whether the adapter is powered. Only available for
	// adapters.
	ColumnPowered
	// ColumnServices: array of service names and Status connection statuses.
	ColumnServices
	// ColumnUuids: string array of human-readable UUIDs.
	ColumnUuids
)

// String returns the name in string for Column.
func (c Column) String() string {
	switch c {
	case ColumnProxy:
		return "Proxy"
	case ColumnProperties:
		return "Properties"
	case ColumnAddress:
		return "Address"
	case ColumnAlias:
		return "Alias"
	case ColumnName:
		return "Name"
	case ColumnType:
		return "Type"
	case ColumnIcon:
		return "Icon"
	case ColumnDefault:
		return "Default"
	case ColumnPaired:
		return "Paired"
	case ColumnTrusted:
		return "Trusted"
	case ColumnConnected:
		return "Connected"
	case ColumnDiscoverable:
		return "Discoverable"
	case ColumnDiscovering:
		return "Discovering"
	case ColumnLegacypairing:
		return "Legacypairing"
	case ColumnPowered:
		return "Powered"
	case ColumnServices:
		return "Services"
	case ColumnUuids:
		return "Uuids"
	default:
		return fmt.Sprintf("Column(%d)", c)
	}
}

// Status: connection status of a service on a particular device. Note that
// BLUETOOTH_STATUS_CONNECTING and BLUETOOTH_STATUS_PLAYING might not be
// available for all services.
type Status C.gint

const (
	// StatusInvalid: whether the status has been set yet.
	StatusInvalid Status = iota
	// StatusDisconnected: whether the service is disconnected.
	StatusDisconnected
	// StatusConnected: whether the service is connected.
	StatusConnected
	// StatusConnecting: whether the service is connecting.
	StatusConnecting
	// StatusPlaying: whether the service is playing (only used by the audio
	// service).
	StatusPlaying
)

// String returns the name in string for Status.
func (s Status) String() string {
	switch s {
	case StatusInvalid:
		return "Invalid"
	case StatusDisconnected:
		return "Disconnected"
	case StatusConnected:
		return "Connected"
	case StatusConnecting:
		return "Connecting"
	case StatusPlaying:
		return "Playing"
	default:
		return fmt.Sprintf("Status(%d)", s)
	}
}

// Type: type of a Bluetooth device. See also BLUETOOTH_TYPE_INPUT and
// BLUETOOTH_TYPE_AUDIO.
type Type C.guint

const (
	// TypeAny: any device, or a device of an unknown type.
	TypeAny Type = 0b1
	// TypePhone: telephone (usually a cell/mobile phone).
	TypePhone Type = 0b10
	// TypeModem: modem.
	TypeModem Type = 0b100
	// TypeComputer: computer, can be a laptop, a wearable computer, etc.
	TypeComputer Type = 0b1000
	// TypeNetwork: network device, such as a router.
	TypeNetwork Type = 0b10000
	// TypeHeadset: headset (usually a hands-free device).
	TypeHeadset Type = 0b100000
	// TypeHeadphones headphones (covers two ears).
	TypeHeadphones Type = 0b1000000
	// TypeOtherAudio: another type of audio device.
	TypeOtherAudio Type = 0b10000000
	// TypeKeyboard: keyboard.
	TypeKeyboard Type = 0b100000000
	// TypeMouse: mouse.
	TypeMouse Type = 0b1000000000
	// TypeCamera: camera (still or moving).
	TypeCamera Type = 0b10000000000
	// TypePrinter: printer.
	TypePrinter Type = 0b100000000000
	// TypeJoypad: joypad, joystick, or other game controller.
	TypeJoypad Type = 0b1000000000000
	// TypeTablet: drawing tablet.
	TypeTablet Type = 0b10000000000000
	// TypeVideo: video device, such as a webcam.
	TypeVideo Type = 0b100000000000000
	// TypeRemoteControl: remote control.
	TypeRemoteControl Type = 0b1000000000000000
	// TypeScanner: scanner.
	TypeScanner Type = 0b10000000000000000
	// TypeDisplay: display.
	TypeDisplay Type = 0b100000000000000000
	// TypeWearable: wearable computer.
	TypeWearable Type = 0b1000000000000000000
	// TypeToy: toy or game.
	TypeToy Type = 0b10000000000000000000
	// TypeSpeakers: audio speaker or speakers.
	TypeSpeakers Type = 0b100000000000000000000
)

// String returns the names in string for Type.
func (t Type) String() string {
	if t == 0 {
		return "Type(0)"
	}

	var builder strings.Builder
	builder.Grow(248)

	for t != 0 {
		next := t & (t - 1)
		bit := t - next

		switch bit {
		case TypeAny:
			builder.WriteString("Any|")
		case TypePhone:
			builder.WriteString("Phone|")
		case TypeModem:
			builder.WriteString("Modem|")
		case TypeComputer:
			builder.WriteString("Computer|")
		case TypeNetwork:
			builder.WriteString("Network|")
		case TypeHeadset:
			builder.WriteString("Headset|")
		case TypeHeadphones:
			builder.WriteString("Headphones|")
		case TypeOtherAudio:
			builder.WriteString("OtherAudio|")
		case TypeKeyboard:
			builder.WriteString("Keyboard|")
		case TypeMouse:
			builder.WriteString("Mouse|")
		case TypeCamera:
			builder.WriteString("Camera|")
		case TypePrinter:
			builder.WriteString("Printer|")
		case TypeJoypad:
			builder.WriteString("Joypad|")
		case TypeTablet:
			builder.WriteString("Tablet|")
		case TypeVideo:
			builder.WriteString("Video|")
		case TypeRemoteControl:
			builder.WriteString("RemoteControl|")
		case TypeScanner:
			builder.WriteString("Scanner|")
		case TypeDisplay:
			builder.WriteString("Display|")
		case TypeWearable:
			builder.WriteString("Wearable|")
		case TypeToy:
			builder.WriteString("Toy|")
		case TypeSpeakers:
			builder.WriteString("Speakers|")
		default:
			builder.WriteString(fmt.Sprintf("Type(0b%b)|", bit))
		}

		t = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if t contains other.
func (t Type) Has(other Type) bool {
	return (t & other) == other
}
